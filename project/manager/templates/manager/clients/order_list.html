{% load static humanize index %}

<style> 
    /* 
    Generic Styling, for Desktops/Laptops 
    */
    table {
      width: 100%;
      border-collapse: collapse;
    }

    th {
      background: #333;
      color: white;
      font-weight: bold;
    }

    td, th {
      padding: 6.2px !important;
      border: 1px solid #ccc;
      text-align: center;
    }
    .draggable {
      height: 61.88px !important;
      text-align: center;
    }

    /* 
    Max width before this PARTICULAR table gets nasty
    This query will take effect for any screen smaller than 760px
    and also iPads specifically.
    */
    @media only screen and (max-width: 760px), (min-device-width: 768px) and (max-device-width: 1024px) {
      .responsive-table-input-matrix {
        display: block;
        position: relative;
        width: 100%;
      }
      .responsive-table-input-matrix:after {
        clear: both;
        content: "";
        display: block;
        font-size: 0;
        height: 0;
        visibility: hidden;
      }
      .responsive-table-input-matrix tbody {
        display: block;
        overflow-x: auto;
        position: relative;
        white-space: nowrap;
        width: auto;
      }
      .responsive-table-input-matrix tbody tr {
        display: inline-block;
        vertical-align: top;
      }
      .responsive-table-input-matrix tbody tr td {
        display: block;
        text-align: center;
      }
      .responsive-table-input-matrix tbody tr td:first-child {
        text-align: center;
      }
      .responsive-table-input-matrix thead {
        display: block;
        float: left;
        margin-right: 10px;
      }
      .responsive-table-input-matrix thead:after {
        clear: both;
        content: "";
        display: block;
        font-size: 0;
        height: 0;
        visibility: hidden;
      }
      .responsive-table-input-matrix thead th:first-of-type {
        height: 1.4em;
      }
      .responsive-table-input-matrix thead th {
        display: block;
        text-align: center;
      }
      .responsive-table-input-matrix thead th:first-child {
        text-align: center;
      }
    }
</style>
<style>
  .board-ordered tr > *:nth-child(2) {
    display: none;
}
</style>
<style>
  .draggable-grip{
    vertical-align: middle;
  }

  .draggable-grip:after {
    width: 3%;
    position: relative;
    text-align: center;
    content: '\f58d';
    font-family: 'Font Awesome\ 5 Free';
    font-weight: 900;
  }
</style>


<h3>
    Ordre des circuits
</h3>
<div class="col text-center">
  <table class="responsive-table-input-matrix table table-hover board-ordered" id="table-order-c" style="display:inline;">
    <thead class="table-dark position-relative" style="z-index:1; opacity:1;">
        <tr>
            <th>#</th>
            <th>#</th>
            <th>Nom</th>
        </tr>
    </thead>
    <tbody>
      {% for circuit in circuits|sort_order_c %}
        <tr style=" background-color:{{gradients|get_value:circuit.id}}">
            <td style="vertical-align:middle;" class="draggable draggable-grip"></td>
            <td style="vertical-align:middle;" class="d-none"><input class="order_clients" type="text" name="order_c__{{circuit.id}}" id="order_c__{{circuit.id}}" value="{{forloop.counter0}}"/></td>
            <td style="vertical-align:middle;">
              <span><strong>{{circuit.name}}</strong> </span>
            </td>
        </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
<h3>
    Ordre des clients
</h3>
<div class='container'>
  <div class='row row-cols-5'>
    {% regroup clients_order by circuit as client_list %}
    {% for circuit, clients_by_circuit in client_list %}
      <div class="col">
        <h4>{{circuit.name}}</h4>
        <table class="responsive-table-input-matrix table table-hover board-ordered" id="table-order-{{forloop.counter0}}">
          <thead class="table-dark position-relative" style="z-index:1; opacity:1;">
              <tr>
                  <th>#</th>
                  <th>#</th>
                  <th>Nom</th>
                  <th>Adresse</th>
              </tr>
          </thead>

          <tbody>
            {% ifchanged clients_by_circuit.circuit %}
              {% if forloop.counter0 != 0 %}
                <tr style="border-collapse: separate; border-spacing:0 20px;">
                  <td colspan="17">
                  </td>
                </tr>
              {% endif %}
            {% endifchanged %}
            {% for client in clients_by_circuit|sort_order %}
              <tr style=" background-color:{{gradients|get_value:circuit.id}}">
                  <td style="vertical-align:middle;" class="draggable draggable-grip"></td>
                  <td style="vertical-align:middle;" class="d-none"><input class="order_clients" type="text" name="order__{{client.id}}" id="order__{{client.id}}" value="{{forloop.counter0}}"/></td>
                  <td style="vertical-align:middle;">
                    <span><strong>{{client.last_name}}</strong> </span><br>
                    <span><strong>{{client.first_name}}</strong></span>
                  </td>
                  <td style="vertical-align:middle;">
                    <span><strong>{{client.address}}</strong>   </span><br>
                    <span><strong>{{client.postcode}}</strong>  </span>
                  </td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    {% endfor %}
  </div>
</div>

{% regroup clients_order by circuit as client_list %}
{% for circuit, clients_by_circuit in client_list %}
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const table = document.getElementById('table-order-{{forloop.counter0}}');

      let draggingEle;
      let draggingRowIndex;
      let placeholder;
      let list;
      let isDraggingStarted = false;

      // The current position of mouse relative to the dragging element
      let x = 0;
      let y = 0;

      // Swap two nodes
      const swap = function (nodeA, nodeB) {
          const parentA = nodeA.parentNode;
          const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;

          // Move `nodeA` to before the `nodeB`
          nodeB.parentNode.insertBefore(nodeA, nodeB);

          // Move `nodeB` to before the sibling of `nodeA`
          parentA.insertBefore(nodeB, siblingA);

      };

      // Check if `nodeA` is above `nodeB`
      const isAbove = function (nodeA, nodeB) {
          // Get the bounding rectangle of nodes
          const rectA = nodeA.getBoundingClientRect();
          const rectB = nodeB.getBoundingClientRect();

          return rectA.top + rectA.height / 2 < rectB.top + rectB.height / 2;
      };

      const cloneTable = function (e) {
          const rect = table.getBoundingClientRect();
          const width = parseInt(window.getComputedStyle(table).width);
          list = document.createElement('div');
          list.classList.add('clone-list');
          list.style.position = 'initial';
          list.style.left = `${rect.left}px`;
          list.style.top = `${rect.top + window.scrollY}px`;
          console.log(list.style.top)
          console.log(list.style.bottom)
          table.parentNode.insertBefore(list, table);

          // Hide the original table
          table.style.visibility = 'hidden';

          table.querySelectorAll('tr').forEach(function (row) {
              // Create a new table from given row
              const item = document.createElement('div');
              item.classList.add('draggable');

              const newTable = document.createElement('table');
              newTable.setAttribute('class', 'clone-table');
              newTable.style.width = `${width}px`;

              const newRow = document.createElement('tr');
              const cells = [].slice.call(row.children);
              cells.forEach(function (cell) {
                  const newCell = cell.cloneNode(true);
                  newCell.style.width = `${parseFloat(window.getComputedStyle(cell).width)}px`;
                  newRow.appendChild(newCell);
              });

              newTable.appendChild(newRow);
              item.appendChild(newTable);
              list.appendChild(item);
          });
      };

      const mouseDownHandler = function (e) {
          // Get the original row
          const originalRow = e.target.parentNode;
          draggingRowIndex = [].slice.call(table.querySelectorAll('tr')).indexOf(originalRow);

          // Determine the mouse position
          x = e.clientX;
          y = e.clientY;

          // Attach the listeners to `document`
          document.addEventListener('mousemove', mouseMoveHandler);
          document.addEventListener('mouseup', mouseUpHandler);
      };

      const mouseMoveHandler = function (e) {
          if (!isDraggingStarted) {
              isDraggingStarted = true;

              cloneTable();

              draggingEle = [].slice.call(list.children)[draggingRowIndex];
              draggingEle.classList.add('dragging');

              // Let the placeholder take the height of dragging element
              // So the next element won't move up
              placeholder = document.createElement('div');
              placeholder.classList.add('placeholder');
              draggingEle.parentNode.insertBefore(placeholder, draggingEle.nextSibling);
              placeholder.style.height = `${draggingEle.offsetHeight}px`;
          }

          // Set position for dragging element
          draggingEle.style.position = 'absolute';
          draggingEle.style.top = `${draggingEle.offsetTop + e.clientY - y }px`;
          draggingEle.style.left = `${draggingEle.offsetLeft + e.clientX - x}px`;


          // Reassign the position of mouse
          x = e.clientX;
          y = e.clientY;

          // The current order
          // prevEle
          // draggingEle
          // placeholder
          // nextEle
          const prevEle = draggingEle.previousElementSibling;
          const nextEle = placeholder.nextElementSibling;

          // The dragging element is above the previous element
          // User moves the dragging element to the top
          // We don't allow to drop above the header
          // (which doesn't have `previousElementSibling`)
          if (prevEle && prevEle.previousElementSibling && isAbove(draggingEle, prevEle)) {
              // The current order    -> The new order
              // prevEle              -> placeholder
              // draggingEle          -> draggingEle
              // placeholder          -> prevEle
              swap(placeholder, draggingEle);
              swap(placeholder, prevEle);
              return;
          }

          // The dragging element is below the next element
          // User moves the dragging element to the bottom
          if (nextEle && isAbove(nextEle, draggingEle)) {
              // The current order    -> The new order
              // draggingEle          -> nextEle
              // placeholder          -> placeholder
              // nextEle              -> draggingEle
              swap(nextEle, placeholder);
              swap(nextEle, draggingEle);
          }
      };

      const mouseUpHandler = function () {
          // Remove the placeholder
          placeholder && placeholder.parentNode.removeChild(placeholder);

          draggingEle.classList.remove('dragging');
          draggingEle.style.removeProperty('top');
          draggingEle.style.removeProperty('left');
          draggingEle.style.removeProperty('position');

          // Get the end index
          const endRowIndex = [].slice.call(list.children).indexOf(draggingEle);

          isDraggingStarted = false;

          // Remove the `list` element
          list.parentNode.removeChild(list);

          // Move the dragged row to `endRowIndex`
          let rows = [].slice.call(table.querySelectorAll('tr'));
          draggingRowIndex > endRowIndex
              ? rows[endRowIndex].parentNode.insertBefore(rows[draggingRowIndex], rows[endRowIndex])
              : rows[endRowIndex].parentNode.insertBefore(
                    rows[draggingRowIndex],
                    rows[endRowIndex].nextSibling
                );


          // Bring back the table
          table.style.removeProperty('visibility');

          // Remove the handlers of `mousemove` and `mouseup`
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseup', mouseUpHandler);
          let counter0 = 0;
          table.querySelectorAll('.order_clients').forEach(function(order) {
            order.setAttribute('value', counter0);
            counter0 += 1;
        });
      };

      table.querySelectorAll('tr').forEach(function (row, index) {
          // Ignore the header
          // We don't want user to change the order of header
          {% if forloop.counter0 == 0 %}
            if (index === 0) {
                return;
            }          
          {% endif %}


          const firstCell = row.firstElementChild;
          firstCell.classList.add('draggable');
          firstCell.addEventListener('mousedown', mouseDownHandler);
      });
  });

  </script>
{% endfor %}
<script>
  document.addEventListener('DOMContentLoaded', function () {
    const table = document.getElementById('table-order-c');

    let draggingEle;
    let draggingRowIndex;
    let placeholder;
    let list;
    let isDraggingStarted = false;

    // The current position of mouse relative to the dragging element
    let x = 0;
    let y = 0;

    // Swap two nodes
    const swap = function (nodeA, nodeB) {
        const parentA = nodeA.parentNode;
        const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;

        // Move `nodeA` to before the `nodeB`
        nodeB.parentNode.insertBefore(nodeA, nodeB);

        // Move `nodeB` to before the sibling of `nodeA`
        parentA.insertBefore(nodeB, siblingA);

    };

    // Check if `nodeA` is above `nodeB`
    const isAbove = function (nodeA, nodeB) {
        // Get the bounding rectangle of nodes
        const rectA = nodeA.getBoundingClientRect();
        const rectB = nodeB.getBoundingClientRect();

        return rectA.top + rectA.height / 2 < rectB.top + rectB.height / 2;
    };

    const cloneTable = function (e) {
        const rect = table.getBoundingClientRect();
        const width = parseInt(window.getComputedStyle(table).width);
        list = document.createElement('div');
        list.classList.add('clone-list');
        list.style.position = 'initial';
        list.style.left = `${rect.left}px`;
        list.style.top = `${rect.top + window.scrollY}px`;
        console.log(list.style.top)
        console.log(list.style.bottom)
        table.parentNode.insertBefore(list, table);

        // Hide the original table
        table.style.visibility = 'hidden';

        table.querySelectorAll('tr').forEach(function (row) {
            // Create a new table from given row
            const item = document.createElement('div');
            item.classList.add('draggable');

            const newTable = document.createElement('table');
            newTable.setAttribute('class', 'clone-table');
            newTable.style.width = `${width}px`;

            const newRow = document.createElement('tr');
            const cells = [].slice.call(row.children);
            cells.forEach(function (cell) {
                const newCell = cell.cloneNode(true);
                newCell.style.width = `${parseFloat(window.getComputedStyle(cell).width)}px`;
                newRow.appendChild(newCell);
            });

            newTable.appendChild(newRow);
            item.appendChild(newTable);
            list.appendChild(item);
        });
    };

    const mouseDownHandler = function (e) {
        // Get the original row
        const originalRow = e.target.parentNode;
        draggingRowIndex = [].slice.call(table.querySelectorAll('tr')).indexOf(originalRow);

        // Determine the mouse position
        x = e.clientX;
        y = e.clientY;

        // Attach the listeners to `document`
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
    };

    const mouseMoveHandler = function (e) {
        if (!isDraggingStarted) {
            isDraggingStarted = true;

            cloneTable();

            draggingEle = [].slice.call(list.children)[draggingRowIndex];
            draggingEle.classList.add('dragging');

            // Let the placeholder take the height of dragging element
            // So the next element won't move up
            placeholder = document.createElement('div');
            placeholder.classList.add('placeholder');
            draggingEle.parentNode.insertBefore(placeholder, draggingEle.nextSibling);
            placeholder.style.height = `${draggingEle.offsetHeight}px`;
        }

        // Set position for dragging element
        draggingEle.style.position = 'absolute';
        draggingEle.style.top = `${draggingEle.offsetTop + e.clientY - y }px`;
        draggingEle.style.left = `${draggingEle.offsetLeft + e.clientX - x}px`;


        // Reassign the position of mouse
        x = e.clientX;
        y = e.clientY;

        // The current order
        // prevEle
        // draggingEle
        // placeholder
        // nextEle
        const prevEle = draggingEle.previousElementSibling;
        const nextEle = placeholder.nextElementSibling;

        // The dragging element is above the previous element
        // User moves the dragging element to the top
        // We don't allow to drop above the header
        // (which doesn't have `previousElementSibling`)
        if (prevEle && prevEle.previousElementSibling && isAbove(draggingEle, prevEle)) {
            // The current order    -> The new order
            // prevEle              -> placeholder
            // draggingEle          -> draggingEle
            // placeholder          -> prevEle
            swap(placeholder, draggingEle);
            swap(placeholder, prevEle);
            return;
        }

        // The dragging element is below the next element
        // User moves the dragging element to the bottom
        if (nextEle && isAbove(nextEle, draggingEle)) {
            // The current order    -> The new order
            // draggingEle          -> nextEle
            // placeholder          -> placeholder
            // nextEle              -> draggingEle
            swap(nextEle, placeholder);
            swap(nextEle, draggingEle);
        }
    };

    const mouseUpHandler = function () {
        // Remove the placeholder
        placeholder && placeholder.parentNode.removeChild(placeholder);

        draggingEle.classList.remove('dragging');
        draggingEle.style.removeProperty('top');
        draggingEle.style.removeProperty('left');
        draggingEle.style.removeProperty('position');

        // Get the end index
        const endRowIndex = [].slice.call(list.children).indexOf(draggingEle);

        isDraggingStarted = false;

        // Remove the `list` element
        list.parentNode.removeChild(list);

        // Move the dragged row to `endRowIndex`
        let rows = [].slice.call(table.querySelectorAll('tr'));
        draggingRowIndex > endRowIndex
            ? rows[endRowIndex].parentNode.insertBefore(rows[draggingRowIndex], rows[endRowIndex])
            : rows[endRowIndex].parentNode.insertBefore(
                  rows[draggingRowIndex],
                  rows[endRowIndex].nextSibling
              );


        // Bring back the table
        table.style.removeProperty('visibility');

        // Remove the handlers of `mousemove` and `mouseup`
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        let counter0 = 0;
        table.querySelectorAll('.order_clients').forEach(function(order) {
          order.setAttribute('value', counter0);
          counter0 += 1;
      });
    };

    table.querySelectorAll('tr').forEach(function (row, index) {
        // Ignore the header
        // We don't want user to change the order of header
        {% if forloop.counter0 == 0 %}
          if (index === 0) {
              return;
          }          
        {% endif %}


        const firstCell = row.firstElementChild;
        firstCell.classList.add('draggable');
        firstCell.addEventListener('mousedown', mouseDownHandler);
    });
});

</script>